#!/usr/bin/env python3
"""
Plot scaling study results from CSV files generated by run_scaling.py.

Usage:
    python3 plot_results.py results_strong.csv --study strong --output strong_scaling.png
    python3 plot_results.py results_weak.csv --study weak --output weak_scaling.png
"""

import argparse
import csv
import sys
import matplotlib.pyplot as plt
import matplotlib
import numpy as np

# Use non-interactive backend for server environments
matplotlib.use('Agg')


def load_csv(filename):
    """Load CSV file and return list of dicts."""
    try:
        with open(filename, 'r') as f:
            reader = csv.DictReader(f)
            data = list(reader)
        
        # Convert numeric fields
        for row in data:
            for key in ['mesh_size', 'order', 'procs', 'dofs', 'iterations']:
                if key in row:
                    row[key] = int(row[key])
            for key in ['assemble_time', 'solve_time', 'total_time', 'l2_error']:
                if key in row:
                    row[key] = float(row[key])
            if 'dofs_per_proc' in row:
                row['dofs_per_proc'] = float(row['dofs_per_proc'])
        
        return data
    except FileNotFoundError:
        print(f"ERROR: File not found: {filename}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"ERROR: Failed to load CSV: {e}", file=sys.stderr)
        sys.exit(1)


def plot_strong_scaling(data, output_file):
    """
    Plot strong scaling results: speedup vs number of processors.
    
    Speedup = T(1) / T(p) where T(p) is time on p processors.
    Efficiency = Speedup / p
    """
    print(f"\n=== Plotting Strong Scaling Results ===", file=sys.stderr)
    
    # Group by solver
    solvers = set(row['solver'] for row in data)
    
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))
    fig.suptitle('Strong Scaling Study', fontsize=16, fontweight='bold')
    
    for solver in sorted(solvers):
        solver_data = [row for row in data if row['solver'] == solver]
        solver_data.sort(key=lambda x: x['procs'])
        
        procs = [row['procs'] for row in solver_data]
        solve_times = [row['solve_time'] for row in solver_data]
        total_times = [row['total_time'] for row in solver_data]
        iterations = [row['iterations'] for row in solver_data]
        
        # Compute speedup (relative to 1 processor)
        if procs[0] == 1:
            base_solve_time = solve_times[0]
            base_total_time = total_times[0]
        else:
            print(f"Warning: No baseline (1 proc) data for {solver}, using first entry", 
                  file=sys.stderr)
            base_solve_time = solve_times[0]
            base_total_time = total_times[0]
        
        solve_speedup = [base_solve_time / t for t in solve_times]
        total_speedup = [base_total_time / t for t in total_times]
        efficiency = [s / p for s, p in zip(solve_speedup, procs)]
        
        label = solver.upper()
        
        # Subplot 1: Solve time
        axes[0, 0].plot(procs, solve_times, 'o-', label=label, linewidth=2, markersize=8)
        
        # Subplot 2: Speedup
        axes[0, 1].plot(procs, solve_speedup, 'o-', label=label, linewidth=2, markersize=8)
        
        # Subplot 3: Efficiency
        axes[1, 0].plot(procs, efficiency, 'o-', label=label, linewidth=2, markersize=8)
        
        # Subplot 4: Iterations
        axes[1, 1].plot(procs, iterations, 'o-', label=label, linewidth=2, markersize=8)
    
    # Ideal speedup line
    if data:
        max_procs = max(row['procs'] for row in data)
        ideal_procs = list(range(1, max_procs + 1))
        axes[0, 1].plot(ideal_procs, ideal_procs, 'k--', label='Ideal', linewidth=1.5)
        axes[1, 0].plot(ideal_procs, [1.0] * len(ideal_procs), 'k--', 
                       label='Ideal', linewidth=1.5)
    
    # Configure subplot 1: Solve time
    axes[0, 0].set_xlabel('Number of Processors', fontsize=12)
    axes[0, 0].set_ylabel('Solve Time (s)', fontsize=12)
    axes[0, 0].set_title('Solve Time vs Processors', fontsize=14, fontweight='bold')
    axes[0, 0].grid(True, alpha=0.3)
    axes[0, 0].legend(fontsize=10)
    axes[0, 0].set_yscale('log')
    
    # Configure subplot 2: Speedup
    axes[0, 1].set_xlabel('Number of Processors', fontsize=12)
    axes[0, 1].set_ylabel('Speedup', fontsize=12)
    axes[0, 1].set_title('Speedup vs Processors', fontsize=14, fontweight='bold')
    axes[0, 1].grid(True, alpha=0.3)
    axes[0, 1].legend(fontsize=10)
    
    # Configure subplot 3: Efficiency
    axes[1, 0].set_xlabel('Number of Processors', fontsize=12)
    axes[1, 0].set_ylabel('Parallel Efficiency', fontsize=12)
    axes[1, 0].set_title('Efficiency vs Processors', fontsize=14, fontweight='bold')
    axes[1, 0].grid(True, alpha=0.3)
    axes[1, 0].legend(fontsize=10)
    axes[1, 0].set_ylim([0, 1.2])
    
    # Configure subplot 4: Iterations
    axes[1, 1].set_xlabel('Number of Processors', fontsize=12)
    axes[1, 1].set_ylabel('Iterations', fontsize=12)
    axes[1, 1].set_title('Iterations vs Processors', fontsize=14, fontweight='bold')
    axes[1, 1].grid(True, alpha=0.3)
    axes[1, 1].legend(fontsize=10)
    
    plt.tight_layout()
    plt.savefig(output_file, dpi=150, bbox_inches='tight')
    print(f"Plot saved to {output_file}", file=sys.stderr)


def plot_weak_scaling(data, output_file):
    """
    Plot weak scaling results: time vs number of processors.
    
    Ideal weak scaling: time remains constant as problem size and processors increase.
    """
    print(f"\n=== Plotting Weak Scaling Results ===", file=sys.stderr)
    
    # Group by solver
    solvers = set(row['solver'] for row in data)
    
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))
    fig.suptitle('Weak Scaling Study', fontsize=16, fontweight='bold')
    
    for solver in sorted(solvers):
        solver_data = [row for row in data if row['solver'] == solver]
        solver_data.sort(key=lambda x: x['procs'])
        
        procs = [row['procs'] for row in solver_data]
        solve_times = [row['solve_time'] for row in solver_data]
        total_times = [row['total_time'] for row in solver_data]
        iterations = [row['iterations'] for row in solver_data]
        dofs = [row['dofs'] for row in solver_data]
        dofs_per_proc = [row['dofs_per_proc'] for row in solver_data]
        
        label = solver.upper()
        
        # Subplot 1: Solve time
        axes[0, 0].plot(procs, solve_times, 'o-', label=label, linewidth=2, markersize=8)
        
        # Subplot 2: Total DOFs
        axes[0, 1].plot(procs, dofs, 'o-', label=label, linewidth=2, markersize=8)
        
        # Subplot 3: DOFs per processor
        axes[1, 0].plot(procs, dofs_per_proc, 'o-', label=label, linewidth=2, markersize=8)
        
        # Subplot 4: Iterations
        axes[1, 1].plot(procs, iterations, 'o-', label=label, linewidth=2, markersize=8)
    
    # Ideal weak scaling line (constant time)
    if data:
        max_procs = max(row['procs'] for row in data)
        min_procs = min(row['procs'] for row in data)
        ideal_procs = list(range(min_procs, max_procs + 1))
        
        # Get baseline time for each solver
        for solver in sorted(solvers):
            solver_data = [row for row in data if row['solver'] == solver]
            if solver_data:
                baseline_time = min(row['solve_time'] for row in solver_data)
                axes[0, 0].plot(ideal_procs, [baseline_time] * len(ideal_procs), 
                              '--', alpha=0.5, linewidth=1.5, 
                              label=f'{solver.upper()} ideal')
    
    # Configure subplot 1: Solve time
    axes[0, 0].set_xlabel('Number of Processors', fontsize=12)
    axes[0, 0].set_ylabel('Solve Time (s)', fontsize=12)
    axes[0, 0].set_title('Solve Time vs Processors (Fixed DOFs/proc)', 
                         fontsize=14, fontweight='bold')
    axes[0, 0].grid(True, alpha=0.3)
    axes[0, 0].legend(fontsize=9)
    
    # Configure subplot 2: Total DOFs
    axes[0, 1].set_xlabel('Number of Processors', fontsize=12)
    axes[0, 1].set_ylabel('Total DOFs', fontsize=12)
    axes[0, 1].set_title('Problem Size vs Processors', fontsize=14, fontweight='bold')
    axes[0, 1].grid(True, alpha=0.3)
    axes[0, 1].legend(fontsize=10)
    axes[0, 1].set_yscale('log')
    
    # Configure subplot 3: DOFs per processor
    axes[1, 0].set_xlabel('Number of Processors', fontsize=12)
    axes[1, 0].set_ylabel('DOFs per Processor', fontsize=12)
    axes[1, 0].set_title('Work per Processor', fontsize=14, fontweight='bold')
    axes[1, 0].grid(True, alpha=0.3)
    axes[1, 0].legend(fontsize=10)
    
    # Configure subplot 4: Iterations
    axes[1, 1].set_xlabel('Number of Processors', fontsize=12)
    axes[1, 1].set_ylabel('Iterations', fontsize=12)
    axes[1, 1].set_title('Iterations vs Processors', fontsize=14, fontweight='bold')
    axes[1, 1].grid(True, alpha=0.3)
    axes[1, 1].legend(fontsize=10)
    
    plt.tight_layout()
    plt.savefig(output_file, dpi=150, bbox_inches='tight')
    print(f"Plot saved to {output_file}", file=sys.stderr)


def main():
    parser = argparse.ArgumentParser(
        description='Plot scaling study results')
    
    parser.add_argument('input',
                       help='Input CSV file from run_scaling.py')
    
    parser.add_argument('--study',
                       choices=['strong', 'weak'],
                       required=True,
                       help='Type of scaling study')
    
    parser.add_argument('--output',
                       required=True,
                       help='Output plot file (PNG)')
    
    args = parser.parse_args()
    
    # Load data
    data = load_csv(args.input)
    
    if not data:
        print("ERROR: No data loaded from CSV", file=sys.stderr)
        sys.exit(1)
    
    print(f"Loaded {len(data)} data points", file=sys.stderr)
    
    # Generate plot
    if args.study == 'strong':
        plot_strong_scaling(data, args.output)
    elif args.study == 'weak':
        plot_weak_scaling(data, args.output)


if __name__ == '__main__':
    main()
